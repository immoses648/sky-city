<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sky City</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <style>
    /* 全局样式设置 */
    body {
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: Arial, sans-serif;
      user-select: none; /* 禁止用户选择文本 */
      -webkit-user-select: none; /* 兼容WebKit浏览器 */
    }

    /* 游戏主容器 */
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* 信息面板样式 */
    .info-panel {
      display: flex;
      justify-content: space-between;
      width: 400px;
      margin-bottom: 15px;
      padding: 10px;
      background-color: #f0f0f0;
      border-radius: 5px;
    }

    /* 网格容器样式 */
    .grid-container {
      display: grid;
      grid-template-columns: repeat(20, 40px); /* 20列，每列20px */
      grid-gap: 1px; /* 网格间隙 */
      border: 2px solid #333;
      background-color: #333;
      touch-action: none; /* 禁用触摸默认行为 */
    }

    /* 单元格基础样式 */
    .cell {
      width: 40px;
      height: 40px;
      background-color: #ffffff; /* 地面颜色 */
      cursor: pointer;
      transition: background-color 0.1s; /* 颜色过渡效果 */
      background-position: center;
      background-repeat: no-repeat;
      background-size: contain;
    }

    /* 已铺设道路样式 */
    .cell.road {
      background-image: url("assets/images/road/end.png");
      background-position: center;
      background-repeat: no-repeat;
      background-size: contain;
    }

    .cell.road-road {
      background-image: url("assets/images/road/end.png");
      background-position: center;
      background-repeat: no-repeat;
      background-size: contain;
    }

    .cell.road-horizontal {
      background-image: url("assets/images/road/horizontal.png");
      background-position: center;
      background-repeat: no-repeat;
      background-size: contain;
    }

    .cell.road-vertical {
      background-image: url("assets/images/road/vertical.png");
      background-position: center;
      background-repeat: no-repeat;
      background-size: contain;
    }

    /* 十字路口 */
    .cell.road-cross {
      background-image: url("assets/images/road/cross.png");
    }

    /* 左上转角 */
    .cell.road-top-left {
      background-image: url("assets/images/road/L-bend-vertical-reverse.png");
    }

    /* 右上转角 */
    .cell.road-top-right {
      background-image: url("assets/images/road/L-bend.png");
    }

    /* 左下转角 */
    .cell.road-bottom-left {
      background-image: url("assets/images/road/L-bend-mirror.png");
    }

    /* 右下转角 */
    .cell.road-bottom-right {
      background-image: url("assets/images/road/L-bend-horizontal-reverse.png");
    }

    /* T型路口 */
    .cell.road-t-top {
      background-image: url("assets/images/road/T-junction-reverse.png");
    }

    .cell.road-t-bottom {
      background-image: url("assets/images/road/T-junction.png");
    }

    .cell.road-t-left {
      background-image: url("assets/images/road/T-junction-left.png");
    }

    .cell.road-t-right {
      background-image: url("assets/images/road/T-junction-right.png");
    }

    .cell.road-s-right {
      background-image: url("assets/images/road/left-end.png");
    }

    .cell.road-s-left {
      background-image: url("assets/images/road/right-end.png");
    }

    .cell.road-s-top {
      background-image: url("assets/images/road/bottom-end.png");
    }

    .cell.road-s-bottom {
      background-image: url("assets/images/road/top-end.png");
    }

    /* 道路预览样式 */
    .cell.preview {
      opacity: 0.7; /* 半透明效果 */
    }

    /* 工具按钮样式 */
    .tool-btn {
      padding: 8px 16px;
      margin: 5px;
      cursor: pointer;
      background-color: #4CAF50; /* 绿色按钮 */
      color: white;
      border: none;
      border-radius: 4px;
    }

    /* 激活状态的工具按钮 */
    .tool-btn.active {
      background-color: #45a049;
      box-shadow: 0 0 5px rgba(0,0,0,0.3); /* 阴影效果 */
    }

    /* 硬币显示样式 */
    #coin-display {
      font-weight: bold;
      color: #FFD700; /* 金色 */
    }

    /* 警告信息样式 */
    .warning {
      color: red;
      margin-top: 10px;
      visibility: hidden; /* 默认隐藏 */
    }
  </style>
</head>
<body>
<div id="app">
  <div class="game-container">
    <!-- 信息面板 -->
    <div class="info-panel">
      <div>工具: <span>{{ currentToolDisplay }}</span></div>
      <div>硬币: <span id="coin-display">{{ coins }}</span></div>
    </div>

    <!-- 工具按钮区域 -->
    <div>
      <button
              class="tool-btn"
              :class="{ active: currentTool === 'road' }"
              @click="toggleRoadTool"
      >
        道路工具 (50硬币/格)
      </button>
      <button class="tool-btn" @click="clearAllRoads">清除所有道路</button>
    </div>

    <!-- 警告信息 -->
    <div class="warning" :style="{ visibility: showWarning ? 'visible' : 'hidden' }">
      硬币不足！
    </div>

    <!-- 网格容器 -->
    <div class="grid-container" id="grid">
      <div
              v-for="(cell, index) in cells"
              :key="index"
              class="cell"
              :class="getCellClasses(index)"
              @mousedown="onCellMouseDown(index)"
              @mouseover="onCellMouseOver(index)"
              @touchstart="onCellTouchStart(index)"
              @touchmove.prevent="onCellTouchMove($event)"
      ></div>
    </div>
  </div>
</div>

<script>
  const { createApp, ref, computed, onMounted } = Vue;

  createApp({
    setup() {
      // 游戏状态
      const rows = ref(20);
      const cols = ref(20);
      const coins = ref(1000000);
      const currentTool = ref(null);
      const isBuilding = ref(false);
      const previewCells = ref(new Set());
      const builtRoads = ref(new Set());
      const lastCell = ref(null);
      const showWarning = ref(false);
      const cells = ref(Array.from({ length: 20 * 20 }, (_, i) => ({ index: i })));

      // 计算属性
      const currentToolDisplay = computed(() => {
        return currentTool.value === 'road' ? '道路工具' : '无';
      });

      // 方法
      const toggleRoadTool = () => {
        if (currentTool.value === 'road') {
          currentTool.value = null;
        } else {
          currentTool.value = 'road';
        }
      };

      const clearAllRoads = () => {
        const roadsToUpdate = new Set();

        // 收集所有需要更新的相邻道路
        builtRoads.value.forEach(index => {
          roadsToUpdate.add(index);
          const row = Math.floor(index / cols.value);
          const col = index % cols.value;

          if (row > 0) roadsToUpdate.add(index - cols.value);
          if (row < rows.value - 1) roadsToUpdate.add(index + cols.value);
          if (col > 0) roadsToUpdate.add(index - 1);
          if (col < cols.value - 1) roadsToUpdate.add(index + 1);
        });

        // 返还硬币
        coins.value += builtRoads.value.size * 50;
        builtRoads.value.clear();
        previewCells.value.clear();

        // 更新相邻道路样式
        roadsToUpdate.forEach(index => {
          if (builtRoads.value.has(index)) {
            setRoadStyle(index);
          }
        });
      };

      const onCellMouseDown = (index) => {
        if (currentTool.value === 'road') {
          isBuilding.value = true;
          togglePreview(index);
          lastCell.value = index;
        }
      };

      const onCellMouseOver = (index) => {
        if (isBuilding.value && currentTool.value === 'road' && index !== lastCell.value) {
          togglePreview(index);
          lastCell.value = index;
        }
      };

      const onCellTouchStart = (index) => {
        if (currentTool.value === 'road') {
          isBuilding.value = true;
          togglePreview(index);
          lastCell.value = index;
        }
      };

      const onCellTouchMove = (event) => {
        if (currentTool.value === 'road' && isBuilding.value) {
          const touch = event.touches[0];
          const element = document.elementFromPoint(touch.clientX, touch.clientY);
          if (element && element.classList.contains('cell')) {
            const index = parseInt(element.dataset.index);
            if (index !== lastCell.value) {
              togglePreview(index);
              lastCell.value = index;
            }
          }
        }
      };

      const togglePreview = (index) => {
        if (!builtRoads.value.has(index)) {
          if (previewCells.value.has(index)) {
            previewCells.value.delete(index);
          } else {
            previewCells.value.add(index);
          }
        }
      };

      const confirmBuild = () => {
        const cost = previewCells.value.size * 50;

        if (coins.value >= cost) {
          previewCells.value.forEach(index => {
            builtRoads.value.add(index);
            setRoadStyle(index);
          });

          coins.value -= cost;
          previewCells.value.clear();
          hideWarning();
        } else {
          previewCells.value.clear();
          showWarningMessage();
        }
      };

      const showWarningMessage = () => {
        showWarning.value = true;
        setTimeout(hideWarning, 2000);
      };

      const hideWarning = () => {
        showWarning.value = false;
      };

      const getCellClasses = (index) => {
        const classes = [];

        if (builtRoads.value.has(index)) {
          classes.push('road');
          classes.push(getRoadClass(index));
        } else if (previewCells.value.has(index)) {
          classes.push('preview');
          classes.push(getRoadClass(index));
        }

        return classes.join(' ');
      };

      const getRoadClass = (index) => {
        const row = Math.floor(index / cols.value);
        const col = index % cols.value;

        // 检查四个方向的相邻单元格
        let hasTop = row > 0 && (builtRoads.value.has(index - cols.value) || previewCells.value.has(index - cols.value));
        let hasBottom = row < rows.value - 1 && (builtRoads.value.has(index + cols.value) || previewCells.value.has(index + cols.value));
        let hasLeft = col > 0 && (builtRoads.value.has(index - 1) || previewCells.value.has(index - 1));
        let hasRight = col < cols.value - 1 && (builtRoads.value.has(index + 1) || previewCells.value.has(index + 1));

        if (hasTop && hasBottom && hasLeft && hasRight) {
          return 'road-cross';
        } else if (hasLeft && hasRight && !hasTop && !hasBottom) {
          return 'road-horizontal';
        } else if (hasTop && hasBottom && !hasLeft && !hasRight) {
          return 'road-vertical';
        } else if (hasRight && hasBottom && !hasTop && !hasLeft) {
          return 'road-bottom-right';
        } else if (hasLeft && hasBottom && !hasTop && !hasRight) {
          return 'road-bottom-left';
        } else if (hasRight && hasTop && !hasLeft && !hasBottom) {
          return 'road-top-right';
        } else if (hasLeft && hasTop && !hasRight && !hasBottom) {
          return 'road-top-left';
        } else if (hasTop && hasLeft && hasRight && !hasBottom) {
          return 'road-t-top';
        } else if (hasBottom && hasLeft && hasRight && !hasTop) {
          return 'road-t-bottom';
        } else if (hasLeft && hasTop && hasBottom && !hasRight) {
          return 'road-t-left';
        } else if (hasRight && hasTop && hasBottom && !hasLeft) {
          return 'road-t-right';
        } else if (hasRight && !hasTop && !hasBottom && !hasLeft) {
          return 'road-s-right';
        } else if (hasLeft && !hasTop && !hasBottom && !hasRight) {
          return 'road-s-left';
        } else if (hasTop && !hasLeft && !hasRight && !hasBottom) {
          return 'road-s-top';
        } else if (hasBottom && !hasLeft && !hasRight && !hasTop) {
          return 'road-s-bottom';
        }

        return 'road-road';
      };

      const setRoadStyle = (index) => {
        // 在Vue中，样式是通过类名自动应用的，所以这里只需要触发更新
        // 更新相邻道路
        updateAdjacentRoads(index);
      };

      const updateAdjacentRoads = (index) => {
        const row = Math.floor(index / cols.value);
        const col = index % cols.value;

        // 检查并更新四个方向的相邻道路
        if (row > 0) {
          const topIndex = index - cols.value;
          if (builtRoads.value.has(topIndex) || previewCells.value.has(topIndex)) {
            // 触发响应式更新
            const temp = [...builtRoads.value];
            builtRoads.value = new Set(temp);
          }
        }
        if (row < rows.value - 1) {
          const bottomIndex = index + cols.value;
          if (builtRoads.value.has(bottomIndex) || previewCells.value.has(bottomIndex)) {
            const temp = [...builtRoads.value];
            builtRoads.value = new Set(temp);
          }
        }
        if (col > 0) {
          const leftIndex = index - 1;
          if (builtRoads.value.has(leftIndex) || previewCells.value.has(leftIndex)) {
            const temp = [...builtRoads.value];
            builtRoads.value = new Set(temp);
          }
        }
        if (col < cols.value - 1) {
          const rightIndex = index + 1;
          if (builtRoads.value.has(rightIndex) || previewCells.value.has(rightIndex)) {
            const temp = [...builtRoads.value];
            builtRoads.value = new Set(temp);
          }
        }
      };

      // 鼠标释放事件
      const onMouseUp = () => {
        if (isBuilding.value && currentTool.value === 'road') {
          confirmBuild();
        }
        isBuilding.value = false;
        lastCell.value = null;
      };

      // 触摸结束事件
      const onTouchEnd = () => {
        if (isBuilding.value && currentTool.value === 'road') {
          confirmBuild();
        }
        isBuilding.value = false;
        lastCell.value = null;
      };

      // 生命周期钩子
      onMounted(() => {
        document.addEventListener('mouseup', onMouseUp);
        document.addEventListener('touchend', onTouchEnd);
      });

      return {
        rows,
        cols,
        coins,
        currentTool,
        isBuilding,
        previewCells,
        builtRoads,
        lastCell,
        showWarning,
        cells,
        currentToolDisplay,
        toggleRoadTool,
        clearAllRoads,
        onCellMouseDown,
        onCellMouseOver,
        onCellTouchStart,
        onCellTouchMove,
        getCellClasses,
        setRoadStyle
      };
    }
  }).mount('#app');
</script>
</body>
</html>